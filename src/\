module Main where

import Codec.Picture
import qualified Data.Vector as V
import qualified Data.Vector.Mutable as M
import Control.Monad (forM_, unless)
import Control.Monad.ST

n :: Int -- grid size
n = 32

iters :: Double -- number of iterations
iters = 10.0

dt :: Double -- timestep
dt = 0.01

g :: Double -- gravity
g = -9.81

o :: Double -- overrelaxation
o = 1.9

h :: Double -- grid spacing
h = 1.0

data Cell = Cell
  { density :: Double,
    u :: Double,
    v :: Double,
    newU :: Double,
    newV :: Double,
    sint :: Int,
    pressure :: Double,
    solid :: Bool
  } deriving (Eq)

data SampleType = U | V | S

idx :: Int -> Int -> Int
idx x y = x + y * n

coord :: Int -> (Int, Int)
coord i = (i `mod` n, i `div` n)

color :: Double -> Double -> Cell -> PixelRGB8
color _ _ Cell { solid = True } = PixelRGB8 255 255 255

color minP maxP Cell{ pressure = p } =
    let d = (p - minP) / (maxP - minP)
        c   = floor (255 * d)
    in PixelRGB8 c c c

initSolids :: M.MVector s Cell -> ST s ()
initSolids grid = forM_ [0..M.length grid - 1] $ \i -> do
  cell <- M.read grid i
  let (x,y) = coord i
  let isBorder = x == 0 || y == 0 || x == n - 1 || y == n - 1
  M.write grid i cell { solid = isBorder, sint = if isBorder then 1 else 0 }

diffuse :: M.MVector s Cell -> ST s ()
diffuse grid = forM_ [0..M.length grid - 1] $ \i -> do
  cell <- M.read grid i
  if solid cell
    then return ()
    else M.write grid i cell { v = v cell + g * dt }

resetPressure :: M.MVector s Cell -> ST s ()
resetPressure grid = forM_ [0..M.length grid -1] $ \i -> do
  cell <- M.read grid i
  M.write grid i cell { pressure = 0 }

project :: M.MVector s Cell -> ST s ()
project grid = forM_ [0..iters] $ \_ -> do
  forM_ [0..M.length grid -1] $ \j -> do
    let (x,y) = coord j
    cell <- M.read grid (idx x y)

    unless (solid cell) $ do
      cellx0 <- M.read grid $ idx (x-1) y
      cellx1 <- M.read grid $ idx (x+1) y
      celly0 <- M.read grid $ idx x (y-1)
      celly1 <- M.read grid $ idx x (y+1)

      let sx0 = sint cellx0
          sx1 = sint cellx1
          sy0 = sint celly0
          sy1 = sint celly1

      let d = u cellx1 - u cell + v celly1 - v cell
          s = sx0 + sx1 + sy0 + sy1
          pc = density cell * h / dt
          p = (-d) / fromIntegral s * o
          p' = pressure cell + p * pc

      let u0' = u cell - fromIntegral sx0 * p
          v0' = v cell - fromIntegral sy0 * p
          u1' = u celly1 + fromIntegral sx1 * p
          v1' = u cellx1 + fromIntegral sy1 * p

      M.write grid (idx x y) cell { pressure = p', u = u0', v = v0' }
      M.write grid (idx x (y+1)) celly1 { u = u1' }
      M.write grid (idx (x+1) y) cellx1 { v = v1' }

extrapolateBorder :: M.MVector s Cell -> ST s ()
extrapolateBorder grid = do
  forM_ [0..n - 1] $ \x -> do
    bT <- M.read grid $ idx x 0
    bTA <- M.read grid $ idx x 1
    M.write grid (idx x 0) bT { u = u bTA }

    bB <- M.read grid $ idx x (n-1)
    bBA <- M.read grid $ idx x (n-2)
    M.write grid (idx x (n-1)) bB { u = u bBA }

  forM_ [0..n - 1] $ \y -> do
    bL <- M.read grid $ idx 0 y
    bLA <- M.read grid $ idx 1 y
    M.write grid (idx 0 y) bL { v = v bLA }

    bR <- M.read grid $ idx (n-1) y
    bRA <- M.read grid $ idx (n-2) y
    M.write grid (idx (n-1) y) bR { v = v bRA }

copyVelocities :: M.MVector s Cell -> ST s ()
copyVelocities grid = forM_ [1..M.length grid -1] $ \i -> do
  cell <- M.read grid i
  M.write grid i cell { newU = u cell, newV = v cell }

advectVel :: M.MVector s Cell -> ST s ()
advectVel grid = forM_ [0..M.length grid -1] $ \i -> do
  let (x,y) = coord i
  unless (x == 0 || y == 0 || x == n - 1 || y == n - 1) $ do
    cell <- M.read grid i
    cellx0 <- M.read grid $ idx (x-1) y
    cellx1 <- M.read grid $ idx (x+1) y
    celly0 <- M.read grid $ idx x (y-1)
    celly1 <- M.read grid $ idx x (y+1)

    unless (solid cell || solid cellx0) $ do -- check for the y > n cond
      let avgV = 0.25 * (v cellx0 + v cellx1 + v celly0 + v celly1)
      let xCoord = fromIntegral x * h - dt * u cell
          yCoord = fromIntegral y * h - dt * avgV
      nV <- sample grid xCoord yCoord V
      M.write grid i cell { newV = nV }

    cellUpdated <- M.read grid i
    unless (solid cellUpdated || solid celly0) $ do
      let avgU = 0.25 * (u cellx0 + u cellx1 + u celly0 + u celly1)
      let xCoord = fromIntegral x * h - dt * avgU
          yCoord = fromIntegral y * h - dt * v cellUpdated
      nU <- sample grid xCoord yCoord U
      M.write grid i cellUpdated { newU = nU }


sample :: M.MVector s Cell -> Double -> Double -> SampleType -> ST s Double
sample grid xC yC field = do
  -- clamp to be within worldspace
  let xClamped = max 0.0 (min xC (fromIntegral n - 1.0))
      yClamped = max 0.0 (min yC (fromIntegral n - 1.0))

  -- scalars stored cell centres, velocities stored staggered
  let (offsetX, offsetY) =
        case field of
          U -> (0.0, 0.5 * h)
          V -> (0.5 * h, 0.0)
          S -> (0.5 * h, 0.5 * h)

  -- grid coord
  let x0 = floor (xClamped - offsetX / h) :: Int
      y0 = floor (yClamped - offsetY / h) :: Int

  let w00 = 1 - x0 / h
      w01 = x0 / h
      w10 = 1 - y0 / h
      w11 = y0 / h

  cell <- M.read grid $ idx x0 y0
  cell00 <- M.read grid $ idx
  cell01 <- M.read grid $ idx
  cell10 <- M.read grid $ idx
  cell11 <- M.read grid $ idx


  return 1.0

advectDensity :: M.MVector s Cell -> ST s ()
advectDensity = undefined

simulate :: Int -> M.MVector s Cell -> ST s ()
simulate 0 _ = return ()
simulate i grid = do
  diffuse grid
  resetPressure grid
  project grid
  extrapolateBorder grid
  copyVelocities grid

  simulate (i-1) grid

main :: IO ()
main = do
  grid' <- stToIO $ do
    grid <- M.replicate (n*n)
          Cell
            { density = 0,
              u = 0,
              v = 0,
              newU = 0,
              newV = 0,
              sint = 0,
              pressure = 0,
              solid = False
            }

    initSolids grid

    simulate 1 grid

    return grid

  frozen <- stToIO $ V.freeze grid'

  let compP c1 c2 = compare (pressure c1) (pressure c2)
  let minP = pressure $ V.minimumBy compP frozen
      maxP = pressure $ V.maximumBy compP frozen

  let renderpx :: Int -> Int -> PixelRGB8
      renderpx x y = color minP maxP $ frozen V.! idx x y

  writePng "output.png" $ generateImage renderpx n n

-- TODO sample()
-- TODO advectSmoke()
-- TODO rendersmoke()


  -- unsafeFreeze means cannot use mutable vector after
